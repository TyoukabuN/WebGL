<!DOCTYPE html>
<html>
    <head>
        <script type='text/javascript' src="three.min.js"></script>
        <script id="vertexShader" type="x-shader/x-vertex">
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
        </script>
        <script id="fs_shape_function" type="x-shader/x-fragment">
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;
			uniform vec2 u_mouse;

			float plot(vec2 st)
			{
				return smoothstep(0.02,0.0,abs(st.y-st.x));
			}

			float plot2(vec2 st,float pct)
			{
				return smoothstep(pct,pct+0.02,st.y);
			}
    
            void main() {
                vec2 st = gl_FragCoord.xy/u_resolution.xy;

				st.x = st.x;

				float y = st.x;

				vec3 color = vec3(y);

				float pct = plot2(st,y);

                color =(1.0 - pct)*color + pct * vec3(0.0,1.0,0.0);

				color = vec3(pct);
				gl_FragColor = vec4(color,1.0);
            }
        </script>
        <script id="fs_color" type="x-shader/x-fragment">
            #define PI 3.14159265359
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;
            
            vec3 colorA = vec3(0.149,0.141,0.912);
            vec3 colorB = vec3(1.000,0.833,0.224);
            
            float plot (vec2 st, float pct){
              return  smoothstep( pct-0.01, pct, st.y) -
                      smoothstep( pct, pct+0.01, st.y);
            }

            float plot2(vec2 st, float pct){
                return smoothstep( 0.02, 0.0, abs(pct - st.y));
            }
            
            void main() {
                vec2 st = gl_FragCoord.xy/u_resolution.xy;
                vec3 color = vec3(0.0);
            
                vec3 pct = vec3(st.x);
            
                // pct.r = smoothstep(0.0,1.0, st.x);
                //pct.g = sin(st.x*PI);
                 //pct.b = pow(st.x,0.5);
            
                color = mix(colorA, colorB, pct);
            
                // Plot transition lines for each channel
                color = mix(color,vec3(1.0,0.0,0.0),plot(st,pct.r));
                color = mix(color,vec3(0.0,1.0,0.0),plot(st,pct.g));
                color = mix(color,vec3(0.0,0.0,1.0),plot(st,pct.b));
            
                gl_FragColor = vec4(color,1.0);
            }
        </script>
        <script id = "fs_hsb" type="x-shader/x-fragment">
            uniform vec2 u_resolution;
            uniform float u_time;
            
            vec3 rgb2hsb( in vec3 c ){
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz),
                             vec4(c.gb, K.xy),
                             step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r),
                             vec4(c.r, p.yzx),
                             step(p.x, c.r));
                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),
                            d / (q.x + e),
                            q.x);
            }
            
            //  Function from I単igo Quiles
            //  https://www.shadertoy.com/view/MsS3Wc
            vec3 hsb2rgb( in vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                         6.0)-3.0)-1.0,
                                 0.0,
                                 1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix(vec3(1.0), rgb, c.y);
            }
            
            void main(){
                vec2 st = gl_FragCoord.xy/u_resolution;
                vec3 color = vec3(0.0);
            
                // We map x (0.0 - 1.0) to the hue (0.0 - 1.0)
                // And the y (0.0 - 1.0) to the brightness
                color = hsb2rgb(vec3(st.x,1.0,st.y));
            
                gl_FragColor = vec4(color,1.0);
            }
        </script>
        <script id = "fs_hsb_polar" type="x-shader/x-fragment">
            #define TWO_PI 6.28318530718

            uniform vec2 u_resolution;
            uniform float u_time;

            //  Function from I単igo Quiles
            //  https://www.shadertoy.com/view/MsS3Wc
            vec3 hsb2rgb( in vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                        6.0)-3.0)-1.0,
                                0.0,
                                1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix( vec3(1.0), rgb, c.y);
            }

            void main(){
                vec2 st = gl_FragCoord.xy/u_resolution;
                vec3 color = vec3(0.0);

                // Use polar coordinates instead of cartesian
                vec2 toCenter = vec2(0.5)-st;
                float angle = atan(toCenter.y,toCenter.x);
                float radius = length(toCenter)*2.0;

                // Map the angle (-PI to PI) to the Hue (from 0 to 1)
                // and the Saturation to the radius
                color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));

                gl_FragColor = vec4(color,1.0);
            }
        </script>
        <script id = "fs_hsb_polar_private_wheel" type="x-shader/x-fragment">
            #define TWO_PI 6.28318530718

            uniform vec2 u_resolution;
            uniform float u_time;

            //  Function from I単igo Quiles
            //  https://www.shadertoy.com/view/MsS3Wc
            vec3 hsb2rgb( in vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                        6.0)-3.0)-1.0,
                                0.0,
                                1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix( vec3(1.0), rgb, c.y);
            }

            float wheel(vec2 st,float radis,float width)
            {
                float dis = distance(vec2(0.0),st);
                return step(radis+width,dis) - step(radis+width*2.0,dis);
            }

            float wheelSmooth(vec2 st,float radis,float width)
            {
                float dis = distance(vec2(0.0),st);
                return smoothstep(radis,radis+width,dis) - smoothstep(radis+width,radis+width*2.0,dis);
            }

            void main(){
                vec2 st = gl_FragCoord.xy/u_resolution;
                vec3 color = vec3(0.0);

                // Use polar coordinates instead of cartesian
                vec2 toCenter = vec2(0.5)-st;
                float angle = atan(toCenter.y,toCenter.x);
                float radius = length(toCenter)*2.0;

                // Map the angle (-PI to PI) to the Hue (from 0 to 1)
                // and the Saturation to the radius
                color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));

                float pct = wheel(toCenter,0.2,0.1);
                gl_FragColor = pct * vec4(color,1.0);
            }
        </script>
        <script id = "fs_hsb_private_expand_shrink" type="x-shader/x-fragment">
            #define TWO_PI 6.28318530718

            uniform vec2 u_resolution;
            uniform float u_time;

            //  Function from I単igo Quiles
            //  https://www.shadertoy.com/view/MsS3Wc
            vec3 hsb2rgb( in vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                        6.0)-3.0)-1.0,
                                0.0,
                                1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix( vec3(1.0), rgb, c.y);
            }

            float wheel(vec2 st,float radius,float width)
            {
                float dis = distance(vec2(0.0),st);
                return step(radius+width,dis) - step(radius+width*2.0,dis);
            }

            float layer(vec2 st,float startY,float width)
            {
                return step(startY,st.y) - step(startY + width,st.y);
            }

            float plotX(vec2 st,float pct,float width)
            {
                return smoothstep(pct-width,pct,st.x) - smoothstep(pct,pct+width,st.x);
            }

            float wheelSmooth(vec2 st,float radius,float width)
            {
                float dis = distance(vec2(0.0),st);
                return smoothstep(radius,radius+width,dis) - smoothstep(radius+width,radius+width*2.0,dis);
            }

            void main(){
                vec2 st = gl_FragCoord.xy/u_resolution;
                vec3 color = vec3(0.0);

                // Use polar coordinates instead of cartesian
                vec2 toCenter = vec2(0.5)-st;
                float angle = atan(toCenter.y,toCenter.x);
                float radius = length(toCenter)*2.0;

                // Map the angle (-PI to PI) to the Hue (from 0 to 1)
                // and the Saturation to the radius
                //color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));

                //float pct = wheel(toCenter,0.2,0.1);
                float pct = 1.0;
                

                pct = layer(st,0.8,0.2);
                float pct2 = plotX(st,abs(sin(st.x)),0.1);
                //color = vec3(pct2);
                color = pct2 * (pct * vec3(1.0,0.0,0.0)) + (1.0 - pct2) + color;
                pct = layer(st,0.6,0.2);
                color += pct * vec3(0.0,1.0,0.0);

                gl_FragColor = vec4(color,1.0);
            }
        </script>
    </head>
    <style>
        body {margin: 0;}
    </style>
    
    <body>
        <div id="container"></div>
        <script>
            var container;
            var camera, scene, renderer;
            var uniforms;

            init();
            animate();

            function init() {
                container = document.getElementById( 'container' );

                camera = new THREE.Camera();
                camera.position.z = 1;

                scene = new THREE.Scene();

                var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

                uniforms = {
                    u_time: { type: "f", value: 1.0 },
                    u_resolution: { type: "v2", value: new THREE.Vector2() },
                    u_mouse: { type: "v2", value: new THREE.Vector2() }
                };

                var material = new THREE.ShaderMaterial( {
                    uniforms: uniforms,
                    vertexShader: document.getElementById( 'vertexShader' ).textContent,
                    fragmentShader: document.getElementById( 'fs_hsb_private_expand_shrink' ).textContent
                } );

                var mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );

                container.appendChild( renderer.domElement );

                onWindowResize();
                window.addEventListener( 'resize', onWindowResize, false );

                document.onmousemove = function(e){
                uniforms.u_mouse.value.x = e.pageX
                uniforms.u_mouse.value.y = e.pageY
                }
            }

            function onWindowResize( event ) {
                renderer.setSize( window.innerWidth, window.innerHeight );
                uniforms.u_resolution.value.x = renderer.domElement.width;
                uniforms.u_resolution.value.y = renderer.domElement.height;
            }

            function animate() {
                requestAnimationFrame( animate );
                render();
            }

            function render() {
                uniforms.u_time.value += 0.05;
                renderer.render( scene, camera );
            }
        </script>
    </body>
</html>